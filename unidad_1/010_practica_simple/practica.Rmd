---
title: "Basic Example"
author: "Samuel Castillo"
date: "2025-10-01"
output: 
  github_document: default
  html_document: default
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_format = "all") })
editor_options: 
  markdown: 
    wrap: 72
---

# Librerias
```{r librerias}

# library(mrgsolve)
library(ggplot2)

library(dplyr)
```

# Letura de datos

```{r}
data_path <- file.path("C:/Users/KoMeTa/OneDrive - Universidad Privada del Valle/CODES/EST4/unidad_1/010_practica_simple/archive")
data_file <- file.path(data_path, "vgsales.csv")
data.vg.raw <- read.csv(data_file,
                 stringsAsFactors = F,na.strings = ".",header = T,sep=",")
head(data.vg.raw)
str(data.vg.raw)
```

```{r}
summary(data.vg.raw)
```

# Limpieza de datos


```{r}
data.vg <- data.vg.raw 
data.vg$Platform <- factor(data.vg$Platform)
data.vg$Year <- as.numeric(data.vg$Year)
summary(data.vg)
```
```{r}
str(data.vg.raw)
unique(data.vg.raw$Year)
filter(data.vg.raw, Year=="N/A")

```


```{r}
unique(data.vg$Platform)
filter(data.vg, Name=="FIFA 15")
hist(data.vg$NA_Sales )
```

Calculemos la proporcion de los datos missings Esto nos ayudará a decidir la estrategia (borrar vs. llenar)

```{r}
# Contar NA por columna
na_por_columna <- colSums(is.na(data.vg))
print("NA por columna:")
print(na_por_columna)

# Porcentaje de NA por columna
porcentaje_na <- colMeans(is.na(data.vg)) * 100
print("Porcentaje de NA por columna:")
print(round(porcentaje_na, 2))

```



```{r}
unique(data.vg$Publisher)
filter(data.vg, Publisher==" ")

```

A año le faltan 271 valores (aprox 1,63%). Dado que este porcentajee es muy pequeño, la estrategia más segura y sencilla es eliminar estas filas. Intentar 'adivinar' (imputar) el año o la editorial podría generar interferencias y llevar a conclusiones incorrectas. Queremos que nuestro análisis se base en datos completos y precisos. Usaremos .dropna() para eliminar las filas que contienen valores NaN en las columnas especificadas.



```{r}
# DataFrame de ejemplo con missing values

print("DataFrame original:")
print(data.vg)
cat("Filas originales:", nrow(data.vg), "\n\n")

# Método 1: na.omit() - Elimina filas con cualquier NA
df_sin_na <- na.omit(data.vg)
print("Con na.omit():")
print(df_sin_na)
cat("Filas después de na.omit():", nrow(df_sin_na), "\n\n")

# Método 2: complete.cases() - Más control
df_completo <- data.vg[complete.cases(data.vg), ]
print("Con complete.cases():")
print(df_completo)
cat("Filas después de complete.cases():", nrow(df_completo), "\n")

```


# Tendencia Central

```{r}
unique(data.vg$Platform)
```

Graficos


```{r}

df <- filter(data.vg,NA_Sales<2.5)
# Histograma agrupado por categoría
ggplot( df , aes(x = NA_Sales)) +
  geom_histogram(position = "dodge", alpha = 0.7, bins = 20) +
  labs(title = "Histograma Agrupado de Ventas por Año",
       x = "Ventas",
       y = "Frecuencia") +
  theme_minimal()

```

```{r}
# Establecer la semilla para reproducibilidad
set.seed(200)

# Extraer una muestra aleatoria de 300 observaciones
data_sample <- sample_n(data.vg.raw, 300)

# Mostrar las primeras filas de la muestra
head(data_sample)

# Verificar el tamaño de la muestra
cat("Número de filas en la muestra:", nrow(data_sample), "\n")

#######

# Seleccionar solo las columnas numéricas de la muestra
numeric_vars_sample <- data_sample %>%
  select_if(is.numeric)

# Calcular la media para cada variable numérica en la muestra
sample_means <- sapply(numeric_vars_sample, mean, na.rm = TRUE)
print("Media de la muestra:")
print(sample_means)

# Calcular la desviación estándar para cada variable numérica en la muestra
sample_sds <- sapply(numeric_vars_sample, sd, na.rm = TRUE)
print("Desviación estándar de la muestra:")
print(sample_sds)

#####

# Seleccionar solo las columnas numéricas de la población
numeric_vars_population <- df_completo %>%
  select_if(is.numeric)

# Calcular la media para la población
population_means <- sapply(numeric_vars_population, mean, na.rm = TRUE)
print("Media de la población:")
print(population_means)

# Calcular la desviación estándar para la población
population_sds <- sapply(numeric_vars_population, sd, na.rm = TRUE)
print("Desviación estándar de la población:")
print(population_sds)

# --- CÓDIGO CORREGIDO ---

# 1. Identificar las columnas numéricas UNA SOLA VEZ desde el dataframe completo.
numeric_cols <- names(df_completo)[sapply(df_completo, is.numeric)]

# Imprimir las columnas que se analizarán para estar seguros
print("Columnas numéricas a analizar:")
print(numeric_cols)

# 2. Calcular estadísticas para la POBLACIÓN usando esa lista de columnas
population_means <- sapply(df_completo[numeric_cols], mean, na.rm = TRUE)
population_sds <- sapply(df_completo[numeric_cols], sd, na.rm = TRUE)

# 3. Calcular estadísticas para la MUESTRA usando EXACTAMENTE la misma lista
sample_means <- sapply(data_sample[numeric_cols], mean, na.rm = TRUE)
sample_sds <- sapply(data_sample[numeric_cols], sd, na.rm = TRUE)

# 4. Crear el dataframe de comparación (ahora no dará error)
comparison_df <- data.frame(
  Population_Mean = population_means,
  Sample_Mean = sample_means,
  Population_SD = population_sds,
  Sample_SD = sample_sds
)

# 5. Mostrar la tabla de comparación
print("Tabla de comparación:")
print(comparison_df)

```

